Dependent type theory is an expressive functional programming
language that underlies the deductive system of proof assistants such
as Coq, Agda, and Lean \cite{norell}.  It is a total language,
meaning that every program definable inside type theory is necessarily
terminating. This is an important requirement that ensures the
consistency of the type system. 

Possibly non-terminating computations
and infinite structures such as non-wellfounded trees can be
represented in type theory by extending the type system with
coinductive types. Recursively defined elements of these types
are required to be productive in the sense that every
finite unfolding can be computed in a finite number of steps \cite{Coquand93}.
In Agda's encoding of coinductive types using ``musical notation''
\cite{DA10}, productivity is enforced via a strict obligation: in the
definition of a corecursive function, the recursive
call is required to appear directly under
the application of a constructor. A similar syntactic
check is employed in Coq.
This restriction
typically makes programming with coinductive types cumbersome,
which spawned the search for alternative techniques for ensuring the
well-definedness of corecursive definitions.

We focus on two of these techniques in which productivity is encoded
at the level of types: sized types and guarded recursion. A sized type
 is a type annotated with the number of unfolding that
elements of this type can undergo \cite{Hughes96}. Sized types have been implemented
in Agda and can be used in
combination with coinductive records to specify
coinductive types \cite{Copatterns,AVW-normalization,norell}.  Guarded recursion \cite{Nakano}
is a different approach where the type system is enhanced with a
modality, called ``later'' and written \IC{▻}, encoding time delay in
types. The later modality comes with a general fixpoint combinator for
programming with productive recursive functions and allows the
specification of guarded recursive types, \eg the type of guarded
streams satisfying the isomorphism \F{Str} \Ar{A} \F{≃} \Ar{A} \F{×}
\IC{▻} (\F{Str} \Ar{A}). The tail of a guarded stream is available only
one time step ahead from now, as evidenced by the application of the
later modality to \F{Str} \Ar{A}. Coinductive types can be constructed
from guarded recursive types in type theories that additionally
support clock variables and universal quantification over them
\cite{atkey2013productive,BahrGM17}. Currently there is no
implementation of a calculus with guarded recursion.
%%  nor guarded recursion
%% appears as a selectable feature in a proof assistant.

%% In recent years we witnessed
%% the development of several type theories with primitive support for guarded
%% recursion \cite{atkey2013productive,BahrGM17}. 


%% In dependent type theory, one usually works with terminating
%% computations to ensure consistency.  Yet many interesting programs are
%% not terminating and use possibly infinite data types.  To remain
%% consistent, the computations must be productive.  This means: every
%% finite part of an infinite object can be computed in a finite number
%% of steps.

%% To allow convenient programming and reasoning with infinite objects, we need to extend our type theory with productivity checks.
%% To this end, various approaches have been developed.
%% One is based on sized types \cite{A-sized,AVW-normalization}, where types are assigned a size to indicate the number of unfoldings.
%% These are implemented in Agda \cite{norell2008}.
%% Another is based on guarded recursion \cite{atkey2013productive,BahrGM17}, where the type theory is extended with a general fixpoint combinator.
%% At the current moment, there is no proof assistant based on guarded recursion.

Sized types and guarded recursion are different solutions to the same
problem, but a thorough study of the relation between these two
disciplines is still missing. In this paper we take a first step in
this direction by showing how guarded recursion can be simulated in
Agda using sized types. 

Utilizing techniques for representing ``type theory in type theory''
\cite{AltenkirchK16,Chapman09}, we present an Agda formalization of
the syntax of a simple type theory with guarded recursion. This object
language, which we call \GTT, is a variant of Atkey and McBride's type
system for productive coprogramming \cite{atkey2013productive} in
which the clock context can contain at most one clock. The types of
\GTT\ include the aformentioned \IC{▻} modality and a \IC{□} modality,
a nameless analogue of Atkey and McBride's universal clock
quantification. Clouston \etal \cite{CloustonBGB15} studied a
guarded variant of lambda calculus extended with a \IC{□} operation,
which they call ``constant''.  Our object calculus differs from
theirs in that our judgments are indexed by a clock context, which can
be empty or containing exactly one clock. In this respect \GTT\ is
closer in spirit to Atkey and McBride's language. The design of \GTT\
also has the benefit of allowing a more appealing introduction rule for
\IC{□} than Clouston et al.'s.


Afterwards we develop a categorical semantics
for \GTT\ using sized types. More precisely, we define a presheaf
model where the type formers of simply typed lambda calculus are
evaluated using the standard Kripke semantics. Typically the semantics
of type theories for guarded recursion is given in the topos of
trees or variations thereof \cite{BMSS-synthetic,MannaaM18,Mogelberg14}.
Here, to clarify the connection between guarded recursion and
sized types, we take the preorder of sizes as the indexing
category of our presheaves. This means that types and contexts of \GTT\ are
interpreted as antitone sized types. 
The well-order relation on sizes is fundamental for constructing a
terminating definition of the semantic fixpoint combinator. 

Abel and Vezzosi \cite{AbelV14} also formalized a simple type theory
extended with the later modality in Agda. They focus on operational
properties of the calculus and give a certified proof of strong
normalization. In our work we consider a richer type system and we
formalize its denotational semantics in Agda. Nevertheless, we do not
investigate the dynamic behaviour of our calculus, which we leave to
future work.

%% A detailed account of how to model the characteristic features of
%% \GTT, consisting of the \IC{▻} and
%% \IC{□}  modality together with guarded recursive types, is given in
%% Section \ref{sec:guarded}. 

To summarize, the contributions of this paper are twofold:
\begin{enumerate}
  \item We formalize syntax and semantics of a type theory with
    guarded recursion in Agda. This is the first such denotational model developed using an extension of Martin-L\"of intensional
    type theory as the metalanguage, in contrast with the previous
    set-theoretic models of guarded recursion.
\item The interpretation of the characteristic features of guarded
  recursion crucially requires the employment of sized types. This shows that
  guarded recursive types can be reduced to sized types and
  constitutes a stepping stone towards a clear understanding of  the connections
  between different approaches to productive coprogramming.
%	\item We formally prove the syntax is consistent.
\end{enumerate}

This paper only include the essential parts of our Agda
formalization. The full code is available at
\url{https://github.com/niccoloveltri/agda-clott}. The formalization
uses Agda 2.5.4.1 and Agda standard library 0.16. The paper is
extracted from a literate Agda file, which implies that all the
displayed code has passed Agda's type and termination checker.

%\NV{WIP from this point}

%% To compare the strength of these two approaches, we develop denotational semantics of guarded recursive type theory in a type theory with sized types.
%% This shows that guarded recursive type theory can be done via sized types.
%% More specifically, we define a presheaf model of a simple type theory with guarded recursion \cite{BMSS-synthetic}.
%% Simple types are interpreted via the usual presheaf semantics.

%% In contrast, interpreting guarded recursion and guarded recursive types is more challenging.
%% The most common model in the literature is the topos of trees \cite{BMSS-synthetic}.
%% This is a presheaf topos, whose objects are sets indexed by a natural number.
%% We use a slightly different approach: instead of natural numbers, we use sizes.
%% This means that the required interpretations need to be modified.

%% Our contributions are as follows

%% In Section 2, we describe the meta-theory in which we work.
%% In Section 3, we describe the syntax of the object theory, which is basically a variant of guarded recursion as done by Atkey and McBride \cite{atkey2013productive}.
%% We do this in the form of a deep embedding.
%% More specifically, we define data types representing the contexts, types, terms, and so on, and we give the rules for definitional equality.
%% In Sections 4 and 5, we define the denotational semantics of this syntax.
%% First, we give the interpretation of context, types, and terms in the model, and we show how to interpret simple type formers.
%% Then we show this model supports guarded recursion and guarded recursive types.
%% Finally, we show the syntax is consistent in Section 6.

%% \subsection{Related Work}
%% 
%% Guarded recursion via the later modality was introduced by Nakano \NV{Citation}.
