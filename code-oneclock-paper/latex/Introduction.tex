Dependent type theory is a very expressive functional programming
language that underlies the deductive system of proof assistants such
as Coq, Agda and Lean.  It is a total language,
meaning that every program definable inside type theory is necessarily
terminating. This is an important requirement that ensures the
consistency of the type system. 

Possibly non-terminating computations
and infinite structures such as non-wellfounded trees can be
represented in type theory by extending the type system with
coinductive types. Elements of these types, which we call processes,
are required to be productive \cite{Coquand93} in the sense that every
finite unfolding can be computed in a finite number of steps.
In Agda's encoding of coinductive types using ``musical notation''
\cite{DA10} \NV{What about Coq?}, productivity is achieved using a strict method: in the
definition of corecursive functions, the recursive
call is required to appear directly under
the application of a constructor. This restriction
typically makes programming with processes cumbersome,
which spawned the search for alternative techniques for ensuring the
well-definedness of corecursive definitions.

We focus on two of these techniques in which productivity is encoded
at the level of types: sized types and guarded recursion. A sized type
\cite{Hughes96} is a type annotated with the number of unfolding that
elements of this type can undergo. Sized types have been implemented
in Agda \cite{A-sized,AVW-normalization} and can be used in
combination with coinductive records for the specification of
coinductive types \cite{Copatterns}.  Guarded recursion \cite{Nakano}
is a different approach where the type system is enhanced with a
modality, called ``later'' and written \IC{▻}, encoding time delay in
types. The later modality comes with a general fixpoint combinator for
programming with productive recursive functions and allows the
specification of guarded recursive types, \eg the type of guarded
streams satisfying the isomorphism \F{Str} \Ar{A} \F{≃} \Ar{A} \F{×}
\IC{▻} (\F{Str} \F{A}). The tail of a guarded stream is available only
one time step ahead from now, as evidenced by the application of the
later modality to \F{Str} \F{A}. Coinductive types can be constructed
from guarded recursive types in type theories that additionally
support clock variables and universal quantification over them
\cite{atkey2013productive,BahrGM17}. Currently there is no
implementation of a calculus with guarded recursion.
%%  nor guarded recursion
%% appears as a selectable feature in a proof assistant.

%% In recent years we witnessed
%% the development of several type theories with primitive support for guarded
%% recursion \cite{atkey2013productive,BahrGM17}. 


%% In dependent type theory, one usually works with terminating
%% computations to ensure consistency.  Yet many interesting programs are
%% not terminating and use possibly infinite data types.  To remain
%% consistent, the computations must be productive.  This means: every
%% finite part of an infinite object can be computed in a finite number
%% of steps.

%% To allow convenient programming and reasoning with infinite objects, we need to extend our type theory with productivity checks.
%% To this end, various approaches have been developed.
%% One is based on sized types \cite{A-sized,AVW-normalization}, where types are assigned a size to indicate the number of unfoldings.
%% These are implemented in Agda \cite{norell2008}.
%% Another is based on guarded recursion \cite{atkey2013productive,BahrGM17}, where the type theory is extended with a general fixpoint combinator.
%% At the current moment, there is no proof assistant based on guarded recursion.

Sized types and guarded recursion are different solution to the same
problem, but a thorough study of the relation between these two
disciplines is still missing. In this paper we take a first step in
this direction by showing how guarded recursion can be simulated in
Agda using sized types. 


\NV{WIP from this point}

To compare the strength of these two approaches, we develop denotational semantics of guarded recursive type theory in a type theory with sized types.
This shows that guarded recursive type theory can be done via sized types.
More specifically, we define a presheaf model of a simple type theory with guarded recursion \cite{BMSS-synthetic}.
Simple types are interpreted via the usual presheaf semantics.

In contrast, interpreting guarded recursion and guarded recursive types is more challenging.
The most common model in the literature is the topos of trees \cite{BMSS-synthetic}.
This is a presheaf topos, whose objects are sets indexed by a natural number.
We use a slightly different approach: instead of natural numbers, we use sizes.
This means that the required interpretations need to be modified.

Our contributions are as follows
\begin{enumerate}
	\item We give a new denotational semantics of guarded recursive type theory in type theory;
	\item We show that guarded recursion can be interpreted in sized types.
	\item We formally prove the syntax is consistent.
\end{enumerate}

In Section 2, we describe the meta-theory in which we work.
In Section 3, we describe the syntax of the object theory, which is basically a variant of guarded recursion as done by Atkey and McBride \cite{atkey2013productive}.
We do this in the form of a deep embedding.
More specifically, we define data types representing the contexts, types, terms, and so on, and we give the rules for definitional equality.
In Sections 4 and 5, we define the denotational semantics of this syntax.
First, we give the interpretation of context, types, and terms in the model, and we show how to interpret simple type formers.
Then we show this model supports guarded recursion and guarded recursive types.
Finally, we show the syntax is consistent in Section 6.

%% \subsection{Related Work}
%% 
%% Guarded recursion via the later modality was introduced by Nakano \NV{Citation}.
