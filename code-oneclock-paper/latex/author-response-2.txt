

We thank the reviewers for their comments.

Reviewers 1 and 2 ask why we restrict the clock context to contain at
most one clock variable. The restriction to this case was dictated by
our choice to use Agda with sized types as the metatheory. In Agda,
it is possible to encode semantic clock contexts containing multiple
clocks as lists of sizes or as functions from a finite interval of
natural numbers into sizes. But Agda's support for sized types is
tailored to the case of types depending on exactly one size or on a
finite but precise number of sizes, which makes it cumbersome to work
with types depending on clock contexts containing an indefinite number
of clocks. More technically, as it was privately communicated to us by
Agda implementors, Agda's type inference only works properly for
first-order size contraints.  We believe though that if future Agda
releases add the capability of handling multiple sizes, then it would
be possible to extend the semantics of GTT to a model for the full
Atkey and McBride's type theory. We also believe that extending the
formalization to the multiclock case, while technically challenging,
will not be conceptually harder than the work done so far for GTT.

GTT is less expressive than Atkey and McBride's calculus, since we are
unable to implement nested coinductive types. But the one clock
variant of the calculus still allows the construction of a large
class of coinductive types and it is the subject of active research,
e.g. Clouston et al. [14].

Reviewer 2 is concerned with our restriction of the least fixpoint
operator to strictly positive functors. This restriction is already
present in Atkey and McBride's calculus, which is aimed at
encoding coinductive types using the Nakano modality and it does
not allow solving guarded recursive domain equations such as
D = ▻ D → Nat. GTT is a variant of Atkey and McBride's type theory,
therefore the similar restriction to stricly positive functors.
From the formalization perspective, this restriction allows us to use
Agda's inductive types to model the guarded recursive types of GTT,
as shown in Section 5.3.  In future work we will extend GTT with the
possibility of constructing types such as D = ▻ D → Nat. This can be
done in two ways: extending the language with a universe, which allows
encoding of guarded recursive types as fixpoints in the universe as
shown e.g. by Møgelberg [19]; or considering a μ type former which,
besides stricly positive functors, also operates on functors where all
variables are guarded by an occurrence of the Nakano modality. In the
second option we have to consider strictly positive functors if we
want to encode usual inductive types, such as the natural numbers.

Reviewer 2 and 3also added several points for which we need to provide
more explanation/clarification. We will add those in the next version.
We now comment on more specific questions raised by Reviewers 2.

REVIEWER 2

"The next operator can type certain programs that cannot be typed with
size types as Sacchini shows"

Agda's sized types are more liberal than Sachini's ones allowing more
terms to be typed.

"For me it would be better if you explicitly define the typed lambda
calculi that are compared and make the translation from one calculus
to the other explicit"

We will add a typed lambda calculus notation presentation of GTT in
the Appendix.
Note that our result has a different flavour. We construct a deep and
shallow embedding of a simple type theory with guarded recursion in a
type theory with sized types. The usage of sized types in this model
explains how guarded recursion is simulated by sized types.

"In order to conclude that guarded recursion can be reduced to sized
types one would need to prove something more refined about the
correspondence between the equalities. Not just that True and False
are semantically different."

Definitional equality (of terms) is interpreted as propositional
equality, and thus we have that correspondence. We will add a remark
on this to emphasize this poin.

"guarded recursive types  =  coinductive types"

These are not the same.
The type of guarded streams of satisfies the isomorphism
gStr ≅ Nat × ▻ gStr, while the type of coinductive streams satisfies
Str ≅ Nat × Str. The tail of a term in gStr is only available one time
step ahead from now, while all the element of a term in Str are
available now.

"If mu is a least fixed point former, you can only build inductive
data types which are finite.  How can you build streams using a least
fixed point operator?"

Following Atkey and McBride, the μ type former of GTT allows using
later for strictly positive functors. This is visible at page 4, where
we have ▻ in the definition of Code. We construct the type of guarded
recursive streams and the type of coinductive streams in Section 3.6.

"Are you restricting T for mu X. T in some way using the family Code?
Is the code you are using here even more restrictive than positivity?"

It is indeed more restricting that just positivity.
In the paper, we already comment on the possibility of adding
exponentials with constant domain and the box modality as constructors
of Code. We regret not to have commented on the fact that the codes we
are using disallow the possibility of defining nested inductive
types. We will make sure to add a remark on this.

"That is not the definition of the delay functor in the topos of
trees. The delay functor in the topos of trees shifts all and sets
A(0) into {*}, it is not a limit as your definition shows."

At line 386 we remark that our definition is equivalent to the usual
definition of the delay functor in the topos of trees. The equivalence
is already present in Birkedal et al. [11]. The definition as a limit
is convenient in our case, since the preorder of sizes does not have a
least element, which makes the usual "shifting" definition of the
delay functor not replicable. We will make the equivalence between the
two constructions more explcit.
