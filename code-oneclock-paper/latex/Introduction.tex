In dependent type theory, one usually works with terminating computations to ensure consistency.
Yet many interesting programs are not terminating and use possibly infinite data types.
To remain consistent, the computations must be productive \cite{Coquand93}.
This means: every finite part of an infinite object can be computed in a finite number of steps.

To allow convenient programming and reasoning with infinite objects, we need to extend our type theory with productivity checks.
To this end, various approaches have been developed.
One is based on sized types \cite{A-sized,AVW-normalization}, where types are assigned a size to indicate the number of unfoldings.
These are implemented in Agda \cite{norell2008}.
Another is based on guarded recursion \cite{atkey2013productive,BahrGM17}, where the type theory is extended with a general fixpoint combinator.
At the current moment, there is no proof assistant based on guarded recursion.

To compare the strength of these two approaches, we develop denotational semantics of guarded recursive type theory in a type theory with sized types.
This shows that guarded recursive type theory can be done via sized types.
More specifically, we define a presheaf model of a simple type theory with guarded recursion \cite{BMSS-synthetic}.
Simple types are interpreted via the usual presheaf semantics.

In contrast, interpreting guarded recursion and guarded recursive types is more challenging.
The most common model in the literature is the topos of trees \cite{BMSS-synthetic}.
This is a presheaf topos, whose objects are sets indexed by a natural number.
We use a slightly different approach: instead of natural numbers, we use sizes.
This means that the required interpretations need to be modified.

Our contributions are as follows
\begin{enumerate}
	\item We give a new denotational semantics of guarded recursive type theory in type theory;
	\item We show that guarded recursion can be interpreted in sized types.
	\item We formally prove the syntax is consistent.
\end{enumerate}

In Section 2, we describe the meta-theory in which we work.
In Section 3, we describe the syntax of the object theory, which is basically a variant of guarded recursion as done by Atkey and McBride \cite{atkey2013productive}.
We do this in the form of a deep embedding.
More specifically, we define data types representing the contexts, types, terms, and so on, and we give the rules for definitional equality.
In Sections 4 and 5, we define the denotational semantics of this syntax.
First, we give the interpretation of context, types, and terms in the model, and we show how to interpret simple type formers.
Then we show this model supports guarded recursion and guarded recursive types.
Finally, we show the syntax is consistent in Section 6.

\subsection*{Related Work}